// Copyright snsinfu 2020.
// Distributed under the Boost Software License, Version 1.0.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef INCLUDED_SNSINFU_H5_HPP
#define INCLUDED_SNSINFU_H5_HPP

#include <algorithm>
#include <cassert>
#include <cmath>
#include <cstddef>
#include <cstdint>
#include <initializer_list>
#include <memory>
#include <stdexcept>
#include <string>
#include <type_traits>
#include <utility>
#include <vector>

#include <hdf5.h>


namespace h5
{
    // EXCEPTION -------------------------------------------------------------

    // The exception class used to report an error.
    class exception : public std::runtime_error
    {
    public:
        explicit exception(std::string const& msg)
            : std::runtime_error{msg}
        {
        }
    };


    // UTILITY ---------------------------------------------------------------

    namespace detail
    {
        // Basic optional wrapper for C++14 compilers.
        template<typename T>
        class optional
        {
        public:
            optional() = default;

            optional(T const& value)
                : _value{std::make_unique<T>(value)}
            {
            }

            optional(optional const& other)
                : _value{other ? std::make_unique<T>(*other) : nullptr}
            {
            }

            optional& operator=(optional const& other)
            {
                optional tmp = other;
                _value.swap(tmp._value);
                return *this;
            }

            ~optional() = default;


            explicit operator bool() const noexcept
            {
                return bool(_value);
            }

            T& operator*() const
            {
                return *_value;
            }

        private:
            std::unique_ptr<T> _value;
        };
    }


    // RAII ------------------------------------------------------------------

    // Thin RAII wrapper for an hid_t.
    //
    // The `close_fn` template argument is the HDF5 function used to release
    // an HID (e.g., `H5Fclose`).
    //
    template<herr_t(& close_fn)(hid_t)>
    class unique_hid
    {
    public:
        // The default constructor creates an empty object.
        unique_hid() = default;

        // The constructor takes the ownership of given HID.
        unique_hid(hid_t hid)
            : _hid{hid}
        {
        }

        ~unique_hid() noexcept
        {
            if (_hid >= 0) {
                close_fn(_hid);
            }
        }

        unique_hid(unique_hid const&) = delete;

        unique_hid(unique_hid&& other) noexcept
        {
            swap(other);
        }

        unique_hid& operator=(unique_hid&& other) noexcept
        {
            unique_hid tmp = std::move(other);
            swap(tmp);
            return *this;
        }

        void swap(unique_hid& other) noexcept
        {
            auto tmp = _hid;
            _hid = other._hid;
            other._hid = tmp;
        }

        operator hid_t() const noexcept
        {
            return _hid;
        }

    private:
        hid_t _hid = -1;
    };


    namespace detail
    {
        template<typename P>
        class h5_memory_guard
        {
        public:
            h5_memory_guard(P const* pointers, std::size_t count)
                : _pointers{pointers}, _count{count}
            {
            }

            ~h5_memory_guard() noexcept
            {
                for (std::size_t i = 0; i < _count; i++) {
                    H5free_memory(static_cast<void*>(_pointers[i]));
                }
            }

            h5_memory_guard(h5_memory_guard const&) = delete;
            h5_memory_guard& operator=(h5_memory_guard const&) = delete;

        private:
            P const* _pointers;
            std::size_t _count;
        };
    }


    // DATA TYPES ------------------------------------------------------------

    using i8 = std::int8_t;
    using i16 = std::int16_t;
    using i32 = std::int32_t;
    using i64 = std::int64_t;
    using u8 = std::uint8_t;
    using u16 = std::uint16_t;
    using u32 = std::uint32_t;
    using u64 = std::uint64_t;
    using f32 = float;
    using f64 = double;
    using str = char*;


    namespace detail
    {
        // Returns variable-length UTF-8 string datatype.
        inline hid_t string_datatype()
        {
            static h5::unique_hid<H5Tclose> const string_type = [] {
                h5::unique_hid<H5Tclose> type = H5Tcopy(H5T_C_S1);
                if (type < 0) {
                    throw h5::exception("failed to copy H5T_C_S1");
                }
                if (H5Tset_cset(type, H5T_CSET_UTF8) < 0) {
                    throw h5::exception("failed to set UTF-8 charset");
                }
                if (H5Tset_size(type, H5T_VARIABLE) < 0) {
                    throw h5::exception("failed to set variable length");
                }
                return type;
            }();
            return string_type;
        }
    }


    // We want to map C++ scalar type to the corresponding HDF5 datatype. We
    // use function templates because datatype values are determined at run
    // time. (H5T_* macros are not constants!)

    template<typename T>
    hid_t storage_type() = delete;

    template<> inline hid_t storage_type<h5::i8>() { return H5T_STD_I8LE; }
    template<> inline hid_t storage_type<h5::i16>() { return H5T_STD_I16LE; }
    template<> inline hid_t storage_type<h5::i32>() { return H5T_STD_I32LE; }
    template<> inline hid_t storage_type<h5::i64>() { return H5T_STD_I64LE; }
    template<> inline hid_t storage_type<h5::u8>() { return H5T_STD_U8LE; }
    template<> inline hid_t storage_type<h5::u16>() { return H5T_STD_U16LE; }
    template<> inline hid_t storage_type<h5::u32>() { return H5T_STD_U32LE; }
    template<> inline hid_t storage_type<h5::u64>() { return H5T_STD_U64LE; }
    template<> inline hid_t storage_type<h5::f32>() { return H5T_IEEE_F32LE; }
    template<> inline hid_t storage_type<h5::f64>() { return H5T_IEEE_F64LE; }
    template<> inline hid_t storage_type<h5::str>() { return detail::string_datatype(); }

    template<typename T>
    hid_t memory_type() = delete;

    template<> inline hid_t memory_type<signed char>() { return H5T_NATIVE_SCHAR; }
    template<> inline hid_t memory_type<short>() { return H5T_NATIVE_SHORT; }
    template<> inline hid_t memory_type<int>() { return H5T_NATIVE_INT; }
    template<> inline hid_t memory_type<long>() { return H5T_NATIVE_LONG; }
    template<> inline hid_t memory_type<long long>() { return H5T_NATIVE_LLONG; }
    template<> inline hid_t memory_type<unsigned char>() { return H5T_NATIVE_UCHAR; }
    template<> inline hid_t memory_type<unsigned short>() { return H5T_NATIVE_USHORT; }
    template<> inline hid_t memory_type<unsigned int>() { return H5T_NATIVE_UINT; }
    template<> inline hid_t memory_type<unsigned long>() { return H5T_NATIVE_ULONG; }
    template<> inline hid_t memory_type<unsigned long long>() { return H5T_NATIVE_ULLONG; }
    template<> inline hid_t memory_type<float>() { return H5T_NATIVE_FLOAT; }
    template<> inline hid_t memory_type<double>() { return H5T_NATIVE_DOUBLE; }
    template<> inline hid_t memory_type<char*>() { return detail::string_datatype(); }
    template<> inline hid_t memory_type<char const*>() { return detail::string_datatype(); }


    // ENUM DEFINITION -------------------------------------------------------

    // Holds a list of enum members.
    template<typename T>
    class enums
    {
    public:
        // Type of enumerated value.
        using value_type = T;

        struct member
        {
            std::string name;
            value_type value;
        };

        using iterator = typename std::vector<member>::const_iterator;

        // Creates an empty enumeration list.
        enums() = default;

        // Creates an enumeration list containing given members.
        enums(std::initializer_list<member> const& members)
            : _members(members)
        {
        }

        // Returns the number of members in the enumeration list.
        std::size_t size() const
        {
            return _members.size();
        }

        iterator begin() const
        {
            return _members.begin();
        }

        iterator end() const
        {
            return _members.end();
        }

        // Returns a pointer to the name of given value in the enumeration list.
        std::string const* name(value_type value) const
        {
            for (auto const& member : _members) {
                if (member.value == value) {
                    return &member.name;
                }
            }
            return nullptr;
        }

        // Returns a pointer to the value of given name in the enumeration list.
        value_type const* value(std::string const& name) const
        {
            for (auto const& member : _members) {
                if (member.name == name) {
                    return &member.value;
                }
            }
            return nullptr;
        }

        // Inserts a new member to the enumeration list.
        void insert(std::string const& name, value_type value)
        {
            _members.push_back({name, value});
        }

    private:
        std::vector<member> _members;
    };


    namespace detail
    {
        // Returns true if `datatype` is valid and an enum.
        inline
        bool is_enum_datatype(hid_t datatype)
        {
            return H5Tget_class(datatype) == H5T_ENUM;
        }


        // Checks an enum datatype against enumerated list.
        template<typename D>
        void check_enum_type(hid_t datatype, h5::enums<D> const& enums)
        {
            if (!is_enum_datatype(datatype)) {
                throw h5::exception("datatype is not an enum");
            }

            if (H5Tget_size(datatype) != sizeof(D)) {
                // libhdf5 does not support integral type conversion for enum
                // values. It silently corrupts memory if the sizes mismatch.
                throw h5::exception("unexpected enum datatype size");
            }

            int const member_count = H5Tget_nmembers(datatype);
            if (member_count < 0) {
                throw h5::exception("failed to get enum member count");
            }

            if (enums.size() != static_cast<std::size_t>(member_count)) {
                throw h5::exception("enum member count mismatch");
            }

            for (auto const& member : enums) {
                D actual_value;
                if (H5Tenum_valueof(datatype, member.name.c_str(), &actual_value) < 0) {
                    throw h5::exception("failed to get enum member value");
                }

                if (actual_value != member.value) {
                    throw h5::exception("enum member value mismatch");
                }
            }
        }


        // Creates HDF5 enum type from an enum member list.
        template<typename D>
        h5::unique_hid<H5Tclose> make_enum_type(h5::enums<D> const& enums)
        {
            // The base type of enum must be a native integer. So use memory_type
            // instead of storage_type here.
            h5::unique_hid<H5Tclose> type = H5Tenum_create(h5::memory_type<D>());
            if (type < 0) {
                throw h5::exception("failed to create enum type");
            }

            for (auto const& member : enums) {
                if (H5Tenum_insert(type, member.name.c_str(), &member.value) < 0) {
                    throw h5::exception("failed to insert enum memher");
                }
            }

            return type;
        }
    }


    // SHAPE -----------------------------------------------------------------

    // Shape of a simple dataset (multi-dimensional array).
    template<int rank>
    struct shape
    {
        // Size of each dimension.
        std::size_t dims[rank] = {};

        // Returns the total number of elements in the hypercube of this shape.
        std::size_t size() const noexcept
        {
            std::size_t prod = dims[0];
            for (int i = 1; i < rank; i++) {
                prod *= dims[i];
            }
            return prod;
        }
    };

    template<>
    struct shape<0>
    {
    };

    template<int rank>
    bool operator==(h5::shape<rank> const& s1, h5::shape<rank> const& s2)
    {
        for (int i = 0; i < rank; i++) {
            if (s1.dims[i] != s2.dims[i]) {
                return false;
            }
        }
        return true;
    }

    template<>
    inline bool operator==<0>(h5::shape<0> const&, h5::shape<0> const&)
    {
        return true;
    }

    template<int rank>
    bool operator!=(h5::shape<rank> const& s1, h5::shape<rank> const& s2)
    {
        return !(s1 == s2);
    }


    namespace detail
    {
        template<int rank>
        void set_dims(h5::shape<rank> const& shape, hsize_t* dims)
        {
            for (int i = 0; i < rank; i++) {
                dims[i] = static_cast<hsize_t>(shape.dims[i]);
            }
        }

        template<int rank>
        void set_dims(hsize_t const* dims, h5::shape<rank>& shape)
        {
            for (int i = 0; i < rank; i++) {
                shape.dims[i] = static_cast<std::size_t>(dims[i]);
            }
        }
    }


    // BUFFER TRAITS ---------------------------------------------------------

    // Customization point for user-defined buffers.
    //
    // A buffer is a flat memory containing multi-dimensional array in the C
    // (row-major) order. h5 always accepts raw pointers as a general fallback,
    // but for usability a trait is defined for dissecting the pointer and the
    // shape of a buffer.
    template<typename T>
    struct buffer_traits;

    template<typename T>
    struct buffer_traits<std::vector<T>>
    {
        using buffer_type = std::vector<T>;
        using value_type = T;
        static constexpr int rank = 1;

        static h5::shape<rank> shape(buffer_type const& buffer)
        {
            return {buffer.size()};
        }

        static void reshape(buffer_type& buffer, h5::shape<rank> const& s)
        {
            buffer.resize(s.dims[0]);
        }

        static value_type* data(buffer_type& buffer)
        {
            return buffer.data();
        }

        static value_type const* data(buffer_type const& buffer)
        {
            return buffer.data();
        }
    };


    // PATH ------------------------------------------------------------------

    namespace detail
    {
        // Returns the parent of `path`. Returns empty string if `path` has no
        // parent component.
        inline std::string parent_path(std::string const& path)
        {
            auto const sep_pos = path.rfind('/');
            if (sep_pos == std::string::npos) {
                return "";
            }
            return path.substr(0, sep_pos);
        }


        // Returns true if `path` exists in `file`.
        inline bool check_path_exists(hid_t file, std::string const& path)
        {
            auto const parent = detail::parent_path(path);
            if (!parent.empty()) {
                if (!check_path_exists(file, parent)) {
                    return false;
                }
            }

            auto const status = H5Lexists(file, path.c_str(), H5P_DEFAULT);
            if (status < 0) {
                throw h5::exception("failed to check if a path exists");
            }
            return status > 0;
        }
    }


    // AUTO CHUNKING ---------------------------------------------------------

    namespace detail
    {
        // Computes a good chunk shape for the given dataset shape.
        template<int rank>
        h5::shape<rank>
        determine_chunk_size(h5::shape<rank> const& shape, std::size_t value_size)
        {
            // Heuristics from h5py/PyTables.

            constexpr std::size_t KiB = 1024;
            constexpr std::size_t MiB = 1024 * 1024;
            constexpr std::size_t min_size = 8 * KiB;
            constexpr std::size_t base_size = 24 * KiB;
            constexpr std::size_t max_size = 1 * MiB;

            auto const data_size = shape.size() * value_size;
            auto const magnitude = std::log10(double(data_size) / MiB);
            auto const raw_threshold = base_size << int(magnitude);
            auto const threshold = std::min(std::max(raw_threshold, min_size), max_size);

            auto chunk = shape;

            for (int axis = 0; ; ++axis %= rank) {
                auto const chunk_size = chunk.size() * value_size;
                if (chunk_size < threshold) {
                    break;
                }

                chunk.dims[axis] = (chunk.dims[axis] + 1) / 2;
            }

            assert(chunk.size() > 0);

            return chunk;
        }
    }


    // DATASET HANDLING ------------------------------------------------------

    // Optional parameters passed to `dataset::write`.
    struct dataset_options
    {
        // Enables deflate compression when set. The value designates the
        // compression level: 0 for none, 1 for the fastest, 9 for the best.
        //
        // The minimum, fastest compression level 1 tends to be enough when
        // `scaleoffset` is set to a proper value.
        //
        detail::optional<int> compression;

        // Enables "scale-offset" lossy compression when set.
        //
        // This option is effective only for integral and floating-point
        // dataset. For integral dataset, the value designates the number of
        // retained bits. For floating-point dataset, the value designates the
        // base-10 exponent of the scaling factor.
        //
        detail::optional<int> scaleoffset;
    };


    namespace detail
    {
        // Checks the rank of a dataset. Throws an exception if the actual rank
        // is not the expected `rank`. Otherwise, returns the shape.
        template<int rank>
        h5::shape<rank> check_dataset_rank(hid_t dataset)
        {
            h5::unique_hid<H5Sclose> dataspace = H5Dget_space(dataset);
            if (dataspace < 0) {
                throw h5::exception("failed to determine dataspace");
            }

            auto const dataset_rank = H5Sget_simple_extent_ndims(dataspace);
            if (dataset_rank != rank) {
                throw h5::exception("unexpected dataset rank");
            }

            hsize_t dims[rank];
            if (H5Sget_simple_extent_dims(dataspace, dims, nullptr) < 0) {
                throw h5::exception("failed to determine dataset shape");
            }

            h5::shape<rank> shape;
            detail::set_dims(dims, shape);
            return shape;
        }

        template<>
        inline h5::shape<0> check_dataset_rank<0>(hid_t dataset)
        {
            h5::unique_hid<H5Sclose> dataspace = H5Dget_space(dataset);
            if (dataspace < 0) {
                throw h5::exception("failed to determine dataspace");
            }

            auto const dataset_rank = H5Sget_simple_extent_ndims(dataspace);
            if (dataset_rank != 0) {
                throw h5::exception("unexpected dataset rank");
            }

            return {};
        }


        // Checks if the datatype of `dataset` is compatible with `D`. Throws
        // an exception if the types are incompatible. Returns a datatype hid
        // of the dataset on success.
        template<typename D>
        h5::unique_hid<H5Tclose> check_dataset_type(hid_t dataset)
        {
            h5::unique_hid<H5Tclose> datatype = H5Dget_type(dataset);
            if (datatype < 0) {
                throw h5::exception("failed to determine datatype");
            }

            H5T_cdata_t* cdata = nullptr;
            if (H5Tfind(datatype, h5::storage_type<D>(), &cdata) == nullptr) {
                throw h5::exception("incompatible dataset type");
            }

            return datatype;
        }


        // Checks if the datatype of `dataset` is an enum that matches given
        // definition. Throws an `h5::exception` if not.
        template<typename D>
        void check_dataset_enums(hid_t dataset, h5::enums<D> const& enums)
        {
            h5::unique_hid<H5Tclose> datatype = H5Dget_type(dataset);
            if (datatype < 0) {
                throw h5::exception("failed to determine enum datatype");
            }

            detail::check_enum_type(datatype, enums);
        }


        template<typename D>
        H5Z_SO_scale_type_t determine_scaleoffset_type()
        {
            if (std::is_floating_point<D>::value) {
                return H5Z_SO_FLOAT_DSCALE;
            }
            if (std::is_integral<D>::value) {
                return H5Z_SO_INT;
            }
            throw h5::exception("cannot apply scaleoffset to specified datatype");
        }


        // Creates a new simple dataset.
        template<typename D, int rank>
        h5::unique_hid<H5Dclose> create_simple_dataset(
            hid_t file,
            std::string const& path,
            hid_t datatype,
            h5::shape<rank> const& shape,
            h5::dataset_options const& options
        )
        {
            hsize_t dims[rank];
            detail::set_dims(shape, dims);

            h5::unique_hid<H5Sclose> dataspace = H5Screate_simple(rank, dims, nullptr);
            if (dataspace < 0) {
                throw h5::exception("failed to create dataspace");
            }

            // Allow intermediate groups to be automatically created.
            h5::unique_hid<H5Pclose> link_props = H5Pcreate(H5P_LINK_CREATE);
            if (link_props < 0) {
                throw h5::exception("failed to create link props");
            }
            if (H5Pset_create_intermediate_group(link_props, 1) < 0) {
                throw h5::exception("failed to configure link props");
            }

            // Optional filters.
            h5::unique_hid<H5Pclose> dataset_props = H5Pcreate(H5P_DATASET_CREATE);
            if (dataset_props < 0) {
                throw h5::exception("failed to create dataset props");
            }

            if (options.compression || options.scaleoffset) {
                auto const chunk = detail::determine_chunk_size(shape, sizeof(D));

                hsize_t chunk_dims[rank];
                set_dims(chunk, chunk_dims);
                if (H5Pset_chunk(dataset_props, rank, chunk_dims) < 0) {
                    throw h5::exception("failed to set chunk size");
                }
            }

            if (options.scaleoffset) {
                auto const type = detail::determine_scaleoffset_type<D>();
                auto const factor = *options.scaleoffset;

                if (H5Pset_scaleoffset(dataset_props, type, factor) < 0) {
                    throw h5::exception("failed to set shuffle filter");
                }
            }

            if (options.compression) {
                auto const level = static_cast<unsigned>(*options.compression);

                if (H5Pset_shuffle(dataset_props) < 0) {
                    throw h5::exception("failed to set shuffle filter");
                }
                if (H5Pset_deflate(dataset_props, level) < 0) {
                    throw h5::exception("failed to set deflate filter");
                }
            }

            h5::unique_hid<H5Dclose> dataset = H5Dcreate2(
                file,
                path.c_str(),
                datatype,
                dataspace,
                link_props,
                dataset_props,
                H5P_DEFAULT
            );
            if (dataset < 0) {
                throw h5::exception("failed to create dataset");
            }

            return dataset;
        }


        // Creates a new simple dataset with unlimited first dimension.
        template<typename D, int record_rank>
        h5::unique_hid<H5Dclose> create_unlimited_dataset(
            hid_t file,
            std::string const& path,
            hid_t datatype,
            h5::shape<record_rank> const& record_shape,
            h5::dataset_options const& options
        )
        {
            static constexpr int data_rank = record_rank + 1;

            hsize_t dims[data_rank];
            dims[0] = 0;
            detail::set_dims(record_shape, dims + 1);

            hsize_t max_dims[data_rank];
            max_dims[0] = H5S_UNLIMITED;
            detail::set_dims(record_shape, max_dims + 1);

            h5::unique_hid<H5Sclose> dataspace = H5Screate_simple(data_rank, dims, max_dims);
            if (dataspace < 0) {
                throw h5::exception("failed to create dataspace");
            }

            // Allow intermediate groups to be automatically created.
            h5::unique_hid<H5Pclose> link_props = H5Pcreate(H5P_LINK_CREATE);
            if (link_props < 0) {
                throw h5::exception("failed to create link props");
            }
            if (H5Pset_create_intermediate_group(link_props, 1) < 0) {
                throw h5::exception("failed to configure link props");
            }

            // Optional filters.
            h5::unique_hid<H5Pclose> dataset_props = H5Pcreate(H5P_DATASET_CREATE);
            if (dataset_props < 0) {
                throw h5::exception("failed to create dataset props");
            }

            // Unlimited dataset is always chunked. We first chunk record. If
            // a whole record may fit in a chunk, we extend the chunk so that
            // multiple records are stored in a chunk.
            constexpr std::size_t KiB = 1024;
            constexpr std::size_t base_size = 24 * KiB; // Arbitrary

            auto const record_chunk = detail::determine_chunk_size(record_shape, sizeof(D));
            auto const stream_chunk = 1 + base_size / (record_chunk.size() * sizeof(D));

            hsize_t chunk_dims[data_rank];
            chunk_dims[0] = static_cast<hsize_t>(stream_chunk);
            set_dims(record_chunk, chunk_dims + 1);

            if (H5Pset_chunk(dataset_props, data_rank, chunk_dims) < 0) {
                throw h5::exception("failed to set chunk size");
            }

            if (options.scaleoffset) {
                auto const type = detail::determine_scaleoffset_type<D>();
                auto const factor = *options.scaleoffset;

                if (H5Pset_scaleoffset(dataset_props, type, factor) < 0) {
                    throw h5::exception("failed to set shuffle filter");
                }
            }

            if (options.compression) {
                auto const level = static_cast<unsigned>(*options.compression);

                if (H5Pset_shuffle(dataset_props) < 0) {
                    throw h5::exception("failed to set shuffle filter");
                }
                if (H5Pset_deflate(dataset_props, level) < 0) {
                    throw h5::exception("failed to set deflate filter");
                }
            }

            h5::unique_hid<H5Dclose> dataset = H5Dcreate2(
                file,
                path.c_str(),
                datatype,
                dataspace,
                link_props,
                dataset_props,
                H5P_DEFAULT
            );
            if (dataset < 0) {
                throw h5::exception("failed to create unlimited dataset");
            }

            return dataset;
        }

        // Creates a new scalar dataset.
        template<typename D>
        h5::unique_hid<H5Dclose> create_scalar_dataset(
            hid_t file, std::string const& path, hid_t datatype
        )
        {
            h5::unique_hid<H5Sclose> dataspace = H5Screate(H5S_SCALAR);
            if (dataspace < 0) {
                throw h5::exception("failed to create dataspace");
            }

            // Allow intermediate groups to be automatically created.
            h5::unique_hid<H5Pclose> link_props = H5Pcreate(H5P_LINK_CREATE);
            if (link_props < 0) {
                throw h5::exception("failed to create link props");
            }
            if (H5Pset_create_intermediate_group(link_props, 1) < 0) {
                throw h5::exception("failed to configure link props");
            }

            h5::unique_hid<H5Dclose> dataset = H5Dcreate2(
                file,
                path.c_str(),
                datatype,
                dataspace,
                link_props,
                H5P_DEFAULT,
                H5P_DEFAULT
            );
            if (dataset < 0) {
                throw h5::exception("failed to create dataset");
            }

            return dataset;
        }


        // Reads dataset into given buffer.
        template<typename T>
        void read_dataset(hid_t dataset, T* buf, std::size_t)
        {
            auto const status = H5Dread(
                dataset, h5::memory_type<T>(), H5S_ALL, H5S_ALL, H5P_DEFAULT, buf
            );
            if (status < 0) {
                throw h5::exception("failed to read from dataset");
            }
        }

        template<>
        inline
        void read_dataset<std::string>(hid_t dataset, std::string* buf, std::size_t size)
        {
            std::vector<char*> tmpbuf(size, nullptr);
            detail::h5_memory_guard<char*> guard(tmpbuf.data(), tmpbuf.size());

            read_dataset(dataset, tmpbuf.data(), size);

            for (std::size_t i = 0; i < size; i++) {
                // The stored string can be NULL.
                buf[i] = tmpbuf[i] ? tmpbuf[i] : "";
            }
        }


        // Writes given buffer into dataset.
        template<typename T>
        void write_dataset(hid_t dataset, T const* buf, std::size_t)
        {
            auto const status = H5Dwrite(
                dataset, h5::memory_type<T>(), H5S_ALL, H5S_ALL, H5P_DEFAULT, buf
            );
            if (status < 0) {
                throw h5::exception("failed to write to dataset");
            }
        }

        template<>
        inline
        void write_dataset<std::string>(
            hid_t dataset, std::string const* buf, std::size_t size
        )
        {
            std::vector<char const*> tmpbuf(size, nullptr);
            for (std::size_t i = 0; i < size; i++) {
                tmpbuf[i] = buf[i].c_str();
            }

            write_dataset(dataset, tmpbuf.data(), size);
        }


        // Writes given buffer into dataset as an enum array.
        template<typename T>
        void write_enum_dataset(hid_t dataset, T const* buf, std::size_t, hid_t datatype)
        {
            if (sizeof(T) != H5Tget_size(datatype)) {
                throw h5::exception("buffer is incompatible with enum datatype");
            }

            auto const status = H5Dwrite(
                dataset, datatype, H5S_ALL, H5S_ALL, H5P_DEFAULT, buf
            );
            if (status < 0) {
                throw h5::exception("failed to write to enum dataset");
            }
        }
    }


    // Provides incremental write access to an unliimted HDF5 dataset.
    //
    // `stream_writer` incrementally writes arrays of rank `record_rank` to
    // dataset of rank `record_rank + 1`. The first dimension is assumed to
    // be unlimited.
    //
    template<typename D, int record_rank>
    class stream_writer
    {
        static constexpr int data_rank = record_rank + 1;

    public:
        // Constructor initiates writing to the dataset.
        //
        // Parameters:
        //   file         = The file dataset resides in.
        //   dataset      = The dataset to write to.
        //   record_shape = Shape of each record (sub-array).
        //
        stream_writer(
            hid_t file, hid_t dataset, h5::shape<record_rank> const& record_shape
        )
            : _file{file}, _dataset{dataset}, _record_shape{record_shape}
        {
            _maxdims[0] = H5S_UNLIMITED;
            _datadims[0] = 0;
            _memdims[0] = 1;
            detail::set_dims(record_shape, _maxdims + 1);
            detail::set_dims(record_shape, _datadims + 1);
            detail::set_dims(record_shape, _memdims + 1);

            _dataspace = H5Screate_simple(data_rank, _datadims, _maxdims);
            if (_dataspace < 0) {
                throw h5::exception("failed to create dataspace");
            }

            _memspace = H5Screate_simple(data_rank, _memdims, nullptr);
            if (_memspace < 0) {
                throw h5::exception("failed to create dataspace");
            }
        }

        // Appends a record to the end of the dataset.
        //
        // Parameters:
        //   T   = Type of the buffer. This must be compatible with the
        //         dataset type `D`.
        //   buf = Pointer to the buffer containing flattened record.
        //
        template<typename T>
        void write(T const* buf)
        {
            herr_t status;

            _datadims[0]++;
            status = H5Dset_extent(_dataset, _datadims);
            if (status < 0) {
                throw h5::exception("failed to extend unlimited dataset");
            }

            status = H5Sset_extent_simple(_dataspace, data_rank, _datadims, _maxdims);
            if (status < 0) {
                throw h5::exception("failed to extend dataspace");
            }

            status = H5Sselect_hyperslab(
                _dataspace, H5S_SELECT_SET, _offset, nullptr, _memdims, nullptr
            );
            if (status < 0) {
                throw h5::exception("failed to select hyperslab for streaming write");
            }

            status = H5Dwrite(
                _dataset, h5::memory_type<T>(), _memspace, _dataspace, H5P_DEFAULT, buf
            );
            if (status < 0) {
                throw h5::exception("failed to write to dataset");
            }

            _offset[0] = _datadims[0];
        }

        // Calls `write` with buffer's underlying pointer.
        template<
            typename Buffer,
            typename Tr = h5::buffer_traits<Buffer>,
            typename T = typename Tr::value_type
        >
        void write(Buffer& buffer)
        {
            if (Tr::shape(buffer) != _record_shape) {
                throw h5::exception("buffer has unexpected shape");
            }
            write(Tr::data(buffer));
        }

        // Flushes written data to disk.
        void flush()
        {
            if (H5Fflush(_file, H5F_SCOPE_LOCAL) < 0) {
                throw h5::exception("failed to flush streaming changes to disk");
            }
        }

    private:
        hid_t _file;
        hid_t _dataset;
        h5::shape<record_rank> _record_shape;
        h5::unique_hid<H5Sclose> _dataspace;
        h5::unique_hid<H5Sclose> _memspace;
        hsize_t _maxdims[data_rank] = {};
        hsize_t _datadims[data_rank] = {};
        hsize_t _memdims[data_rank] = {};
        hsize_t _offset[data_rank] = {};
    };


    // Provides read/write access to an HDF5 dataset.
    //
    // The type `D` asserts the expected datatype on disk. `rank` asserts the
    // expected rank of the dataset. Zero `rank` means a scalar dataset.
    //
    template<typename D, int rank>
    class dataset
    {
    public:
        static_assert(rank > 0, "rank must be positive");


        // Tries to open a simple dataset on the `path` in `file`.
        //
        // If the path does not exist, the constructor just initializes the
        // object in the empty state. The object can be used to create a new
        // dataset on the path by calling `write`.
        //
        // If the path is not a simple dataset, or if the type and/or rank
        // assertion fails, the constructor throws an `h5::exception`.
        //
        // The behavior is undefined if a `dataset` object outlives `file`.
        // Make sure `dataset` is destroyed before the file it originates.
        //
        dataset(hid_t file, std::string const& path)
            : _file{file}, _path{path}
        {
            if (detail::check_path_exists(file, path)) {
                _dataset = H5Dopen2(file, path.c_str(), H5P_DEFAULT);
                if (_dataset < 0) {
                    throw h5::exception("failed to open dataset");
                }

                detail::check_dataset_rank<rank>(_dataset);
                detail::check_dataset_type<D>(_dataset);
            }
        }


        // Tries to open a simple enum dataset on the `path` in `file`.
        //
        // This constructor works just like `dataset(file, path)`, but does
        // additional type check of enum members against dataset if exists.
        //
        dataset(hid_t file, std::string const& path, h5::enums<D> const& enums)
            : dataset{file, path}
        {
            _given_datatype = detail::make_enum_type(enums);

            if (_dataset >= 0) {
                detail::check_dataset_enums(_dataset, enums);
            }
        }


        // Returns `true` if the object holds a dataset.
        explicit operator bool() const noexcept
        {
            return _dataset >= 0;
        }


        // Returns the underlying dataset HID. Returns -1 if the object does
        // not hold a dataset.
        hid_t handle() const noexcept
        {
            return _dataset;
        }


        // Retrieves the shape of the dataset. Returns a zero shape if the
        // object does not hold a dataset.
        h5::shape<rank> shape() const noexcept
        {
            if (_dataset < 0) {
                return {};
            }
            return detail::check_dataset_rank<rank>(_dataset);
        }


        // Reads all data from the dataset.
        //
        // The function throws an `h5::exception` if dataset is not open or
        // the given `shape` is not the same as that of dataset.
        //
        // Parameters:
        //   T     = Type of the buffer. This must be compatible with the
        //           dataset type `D`.
        //   buf   = Pointer to the buffer.
        //   shape = Shape of the buffer.
        //
        template<typename T>
        void read(T* buf, h5::shape<rank> const& shape)
        {
            if (this->shape() != shape) {
                throw h5::exception("shape mismatch when reading");
            }

            detail::read_dataset(_dataset, buf, shape.size());
        }


        // Calls `read` with buffer's underlying pointer.
        template<
            typename Buffer,
            typename Tr = h5::buffer_traits<Buffer>,
            typename T = typename Tr::value_type
        >
        void read(Buffer& buffer)
        {
            read(Tr::data(buffer), Tr::shape(buffer));
        }


        // Reads all data from the dataset, resizing buffer to the shape of the
        // dataset. See `read` for details. The buffer traits needs to support
        // `reshape` operation.
        template<
            typename Buffer,
            typename Tr = h5::buffer_traits<Buffer>,
            typename T = typename Tr::value_type
        >
        void read_fit(Buffer& buffer)
        {
            Tr::reshape(buffer, shape());
            read(Tr::data(buffer), Tr::shape(buffer));
        }


        // Writes a new dataset of given shape.
        //
        // The function writes flattened data pointed-to by `buf` to the path.
        // It always creates a new dataset, clobbering existing one if any.
        // Ancestor groups are created if not exist.
        //
        // XXX: Current implementation is not exception safe. Old dataset will
        // be lost if writing a new dataset fails.
        //
        // Parameters:
        //   T       = Type of the buffer. This must be compatible with the
        //             dataset type `D`.
        //   buf     = Pointer to the buffer.
        //   shape   = Shape of the buffer.
        //   options = Options for the newly created dataset.
        //
        template<typename T>
        void write(
            T const* buf,
            h5::shape<rank> const& shape,
            h5::dataset_options const& options
        )
        {
            if (detail::check_path_exists(_file, _path)) {
                if (H5Ldelete(_file, _path.c_str(), H5P_DEFAULT) < 0) {
                    throw h5::exception("failed to delete a path");
                }
            }

            hid_t datatype = h5::storage_type<D>();
            if (_given_datatype >= 0) {
                datatype = _given_datatype;
            }

            _dataset = -1;
            _dataset = detail::create_simple_dataset<D, rank>(
                _file, _path, datatype, shape, options
            );

            if (detail::is_enum_datatype(datatype)) {
                detail::write_enum_dataset(_dataset, buf, shape.size(), datatype);
            } else {
                detail::write_dataset(_dataset, buf, shape.size());
            }

            if (H5Fflush(_file, H5F_SCOPE_LOCAL) < 0) {
                throw h5::exception("failed to flush changes to disk");
            }
        }


        // Calls `write` with default options.
        template<typename T>
        void write(T const* buf, h5::shape<rank> const& shape)
        {
            h5::dataset_options default_options;
            return write(buf, shape, default_options);
        }


        // Calls `write` with buffer's underlying pointer.
        template<
            typename Buffer,
            typename Tr = h5::buffer_traits<Buffer>,
            typename T = typename Tr::value_type
        >
        void write(Buffer const& buffer, h5::dataset_options const& options)
        {
            write(Tr::data(buffer), Tr::shape(buffer), options);
        }


        // Calls `write` with buffer's underlying pointer.
        template<
            typename Buffer,
            typename Tr = h5::buffer_traits<Buffer>,
            typename T = typename Tr::value_type
        >
        void write(Buffer const& buffer)
        {
            write(Tr::data(buffer), Tr::shape(buffer));
        }


        // Starts incremtnal writing to a new unlimited dataset.
        //
        // Parameters:
        //   record_shape = Shape of each record in the dataset.
        //   options      = Options for the newly created dataset.
        //
        h5::stream_writer<D, rank - 1> stream_writer(
            h5::shape<rank - 1> const& record_shape,
            h5::dataset_options const& options
        )
        {
            if (detail::check_path_exists(_file, _path)) {
                if (H5Ldelete(_file, _path.c_str(), H5P_DEFAULT) < 0) {
                    throw h5::exception("failed to delete a path");
                }
            }

            hid_t datatype = h5::storage_type<D>();
            if (_given_datatype >= 0) {
                datatype = _given_datatype;
            }

            _dataset = -1;
            _dataset = detail::create_unlimited_dataset<D>(
                _file, _path, datatype, record_shape, options
            );

            return h5::stream_writer<D, rank - 1>{_file, _dataset, record_shape};
        }


        // Calls `stream_writer` with default options.
        h5::stream_writer<D, rank - 1> stream_writer(h5::shape<rank - 1> const& record_shape)
        {
            h5::dataset_options default_options;
            return stream_writer(record_shape, default_options);
        }


    private:
        hid_t _file;
        std::string _path;
        h5::unique_hid<H5Dclose> _dataset;
        h5::unique_hid<H5Tclose> _given_datatype;
    };


    template<typename D>
    class dataset<D, 0>
    {
    public:
        // Tries to open a scalar dataset on the `path` in `file`.
        //
        // If the path does not exist, the constructor just initializes the
        // object in the empty state. The object can be used to create a new
        // dataset on the path by calling `write`.
        //
        // If the path is not a scalar dataset, or if the type assertion fails,
        // the constructor throws an `h5::exception`.
        //
        // The behavior is undefined if a `dataset` object outlives `file`.
        // Make sure `dataset` is destroyed before the file it originates.
        //
        dataset(hid_t file, std::string const& path)
            : _file{file}, _path{path}
        {
            if (detail::check_path_exists(file, path)) {
                _dataset = H5Dopen2(file, path.c_str(), H5P_DEFAULT);
                if (_dataset < 0) {
                    throw h5::exception("failed to open dataset");
                }

                detail::check_dataset_rank<0>(_dataset);
                detail::check_dataset_type<D>(_dataset);
            }
        }


        // Tries to open a scalar enum dataset on the `path` in `file`.
        //
        // This constructor works just like `dataset(file, path)`, but does
        // additional type check of enum members against dataset if exists.
        //
        dataset(hid_t file, std::string const& path, h5::enums<D> const& enums)
            : dataset{file, path}
        {
            _given_datatype = detail::make_enum_type(enums);

            if (_dataset >= 0) {
                detail::check_dataset_enums(_dataset, enums);
            }
        }


        // Returns `true` if the object holds a dataset.
        explicit operator bool() const noexcept
        {
            return _dataset >= 0;
        }


        // Returns the underlying dataset HID. Returns -1 if the object does
        // not hold a dataset.
        hid_t handle() const noexcept
        {
            return _dataset;
        }


        // Reads value from the dataset.
        //
        // The function throws an `h5::exception` if dataset is not open.
        //
        // Parameters:
        //   T     = Type of the receiver variable. This must be compatible
        //           with the dataset type `D`.
        //   value = Reference to a variable.
        //
        template<typename T>
        void read(T& value)
        {
            detail::check_dataset_rank<0>(_dataset);

            detail::read_dataset(_dataset, &value, 1);
        }


        // Writes a new scalar dataset.
        //
        // The function always creates a new dataset, clobbering existing one
        // if any. Ancestor groups are created if not exist.
        //
        // XXX: Current implementation is not exception safe. Old dataset will
        // be lost if writing a new dataset fails.
        //
        // Parameters:
        //   T     = Type of the scalar value. This must be compatible with the
        //           dataset type `D`.
        //   value = The value to write.
        //
        template<typename T>
        void write(T const& value)
        {
            if (detail::check_path_exists(_file, _path)) {
                if (H5Ldelete(_file, _path.c_str(), H5P_DEFAULT) < 0) {
                    throw h5::exception("failed to delete a path");
                }
            }

            hid_t datatype = h5::storage_type<D>();
            if (_given_datatype >= 0) {
                datatype = _given_datatype;
            }

            _dataset = -1;
            _dataset = detail::create_scalar_dataset<D>(_file, _path, datatype);

            if (detail::is_enum_datatype(datatype)) {
                detail::write_enum_dataset(_dataset, &value, 1, datatype);
            } else {
                detail::write_dataset(_dataset, &value, 1);
            }

            if (H5Fflush(_file, H5F_SCOPE_LOCAL) < 0) {
                throw h5::exception("failed to flush changes to disk");
            }
        }


    private:
        hid_t _file;
        std::string _path;
        h5::unique_hid<H5Dclose> _dataset;
        h5::unique_hid<H5Tclose> _given_datatype;
    };


    // FILE HANDLING ---------------------------------------------------------

    namespace detail
    {
        // Opens an existing HDF5 file.
        inline
        h5::unique_hid<H5Fclose>
        do_open_file(std::string const& filename, bool readonly)
        {
            h5::unique_hid<H5Fclose> file = H5Fopen(
                filename.c_str(),
                readonly ? H5F_ACC_RDONLY : H5F_ACC_RDWR,
                H5P_DEFAULT
            );
            if (file < 0) {
                throw h5::exception("cannot open file");
            }
            return file;
        }


        // Creates an empty HDF5 file.
        inline
        h5::unique_hid<H5Fclose>
        do_create_file(std::string const& filename, bool truncate)
        {
            h5::unique_hid<H5Fclose> file = H5Fcreate(
                filename.c_str(),
                truncate ? H5F_ACC_TRUNC : H5F_ACC_EXCL,
                H5P_DEFAULT,
                H5P_DEFAULT
            );
            if (file < 0) {
                throw h5::exception("cannot create file");
            }
            return file;
        }


        // Opens or creates an HDF5 file based on given mode string.
        inline
        h5::unique_hid<H5Fclose>
        open_file(std::string const& filename, std::string const& mode)
        {
            if (mode == "r") {
                return detail::do_open_file(filename, true);
            }
            if (mode == "r+") {
                return detail::do_open_file(filename, false);
            }
            if (mode == "w") {
                return detail::do_create_file(filename, true);
            }
            if (mode == "w-") {
                return detail::do_create_file(filename, false);
            }
            throw h5::exception("unrecognized file mode");
        }
    }

    // A `file` object provides read/write access to datasets in an HDF5 file.
    class file
    {
    public:
        // Opens or creates an HDF5 file.
        //
        // Parameters:
        //   filename = Path to the HDF5 file.
        //   mode     = One of these four strings: r, r+, w or w-.
        //
        // | Mode | Meaning                                   |
        // |------|-------------------------------------------|
        // | r    | Read only. File must exist.               |
        // | r+   | Read-write. File must exist.              |
        // | w    | Read-write. File is created or truncated. |
        // | w-   | Read-write. File must not exist.          |
        //
        file(std::string const& filename, std::string const& mode)
            : _file{detail::open_file(filename, mode)}
        {
        }


        // Returns the underlying file HID.
        hid_t handle() const noexcept
        {
            return _file;
        }


        // Opens `path` on the file for reading or writing a dataset.
        //
        // Parameters:
        //   D     = Expected type of the dataset elements.
        //   rank  = Expected rank of the dataset (0: scalar, 1: vector,
        //           2: matrix, ...).
        //   path  = HDF5 dataset path.
        //   enums = Assume the dataset to hold enumerated values defined in
        //           this list.
        //
        // Returns:
        //   `h5::dataset` object.
        //
        template<typename D, int rank = 0>
        h5::dataset<D, rank> dataset(std::string const& path)
        {
            return h5::dataset<D, rank>{_file, path};
        }

        template<typename D, int rank = 0>
        h5::dataset<D, rank> dataset(std::string const& path, h5::enums<D> const& enums)
        {
            return h5::dataset<D, rank>{_file, path, enums};
        }

    private:
        h5::unique_hid<H5Fclose> _file;
    };
}

#endif